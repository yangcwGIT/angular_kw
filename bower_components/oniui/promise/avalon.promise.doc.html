<!DOCTYPE html>

<html>
    <head>
        <title>异步列队Promise兼容模块</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <link type="text/css" rel="stylesheet" href="../style/avalon.doc.css"/>
    </head>
    <body>
        <div class="wrapper">
            <h2>promise</h2>
            <fieldset>
                <legend>异步列队</legend>
                <p>这是基于ecma262 v6 的Promise API设计的， 它广泛应用于动画，列队， AJAX等异步操作中，是一个非常强大的范式，希望大家能都能尽快掌握它</p>
            </fieldset>
            <fieldset>
                <legend>使用说明</legend>
                <table class="table-doc">
                    <tr>
                        <th>名字</th><th>默认值</th> <th>说明</th>
                    </tr> 
                    <tr>
                        <td colspan="3" align="center">配置参数</td>
                    </tr>
                    <tr>
                        <td>new Promise(executor)</td>
                        <td></td> 
                        <td>executor为一个函数，它有两个参数resolve、 reject，也都是函数，
                            通过对resolve、 reject传参，从而驱动异步列队执行</td>
                    </tr>
                    <tr>
                        <td>_state</td>
                        <td>"pending"</td> 
                        <td>实例的私自属性，非标准实现，用于标识当前的状态，最开始为pending，
                            当执行了上面的resolve方法后变成fulfilled，
                            当执行了上面的reject方法后变成rejected，
                            此过程不可逆
                        </td>
                    </tr>
                    <tr>
                        <td>_fired</td>
                        <td>false</td> 
                        <td>实例的私自属性，非标准实现，用于标识实例是否已经执行过resolve或reject方法
                        </td>
                    </tr>

                    <tr>
                        <td>Promise.resolve(value)</td>
                        <td>静态方法</td> 
                        <td>将一个值转换为一个Promise对象,如<br/>
                            Promise.resolve(123).then(alert)  <br/>
                            相当于<br/>
                            Promise.resolve(Promise.resolve(123)).then(alert) 
                        </td>
                    </tr>
                    <tr>
                        <td>then(onSuccess, onFail)</td>
                        <td>原型方法</td> 
                        <td>添加各种回调
                        </td>
                    </tr>
                    <tr>
                        <td>catch( onFail)</td>
                        <td>原型方法</td> 
                        <td>添加失败回调
                        </td>
                    </tr>
                    <tr>
                        <td>Promise.reject(value)</td>
                        <td>静态方法</td> 
                        <td>将一个值转换为一个Promise对象,如<br/>
                            Promise.reject(123).catch(alert)  <br/>
                            相当于<br/>
                            Promise.reject(Promise.reject(123)).catch(alert) 
                        </td>
                    </tr>
                    <tr>
                        <td>Promise.all(array)</td>
                        <td>静态方法</td> 
                        <td>待到数组的所有Promise都resolve后，执行新Promise的then方法中的resolve回调
                        </td>
                    </tr>
                    <tr>
                        <td>Promise.race(array)</td>
                        <td>静态方法</td> 
                        <td>只要数组中有一个Promise被resolve后，执行新Promise的then方法中的resolve回调
                        </td>
                    </tr>
                </table>
            </fieldset>
            <ul>
                <li><a href="avalon.promise.ex1.html">没有延时的then链式调用</a></li>
                <li><a href="avalon.promise.ex2.html">存在延时的then链式调用</a></li>
                <li><a href="avalon.promise.ex3.html">第二个Promise以第一个Promise作为参数传入resolve方法中</a></li>
                <li><a href="avalon.promise.ex4.html">第二个Promise以第一个Promise作为参数传入reject方法中</a></li>
                <li><a href="avalon.promise.ex5.html">第二个Promise以第一个thenable对象作为参数传入resolve方法中</a></li>
                <li><a href="avalon.promise.ex6.html">第二个Promise以第一个thenable对象作为参数传入reject方法中</a></li>
                <li><a href="avalon.promise.ex7.html">每一个Promise总以上一个Promise作为参数传入resolve方法中</a></li>
                <li><a href="avalon.promise.ex8.html">Promise.all</a></li>
                <li><a href="avalon.promise.ex9.html">Promise.race</a></li>
                <li><a href="avalon.promise.ex10.html">Promise.prototype.reject</a></li>
                <li><a href="avalon.promise.ex11.html">Promise.all([]).then(callback)</a></li>
            </ul>
        </div>

    </body>
</html>
